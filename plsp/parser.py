# This file was generated by SableCC (http://www.sablecc.org/). 

from types import StringType, FileType, ListType

def caller(n=1):
    import inspect
    return inspect.getouterframes(inspect.currentframe())[n][3]
	
def abstract():
    raise NotImplementedError(caller() + ' must be implemented in subclass')

class Stack(list):
    def push(self, value):
        self.append(value)
    
    def peek(self):
        return self[len(self)-1]
    
    def empty(self):
        return len(self) == 0
        	
class PushbackReader(object):
    def __init__(self, reader):
        self.__reader = reader
        self.__stack = Stack()

    def peek (self):
        if (len(self.__stack) > 0 ): 
    	    result = self.__stack.peek()
        else:
    	    result = self.__reader.read(1)
    	    self.__reader.seek(-1, 1) # go back to the previous position
        return result

    def read (self):
        if ( len(self.__stack) > 0 ):
    	    return self.__stack.pop()
        return self.__reader.read(1)

    def unread (self, c):
        self.__stack.append(c)

class StringBuffer(object):
  def __init__(self, obj=None):
      self.buffer = [] 
      if not(obj == None):
          if isinstance(obj, StringType):
              self.buffer.extend(list(obj))
          else:
              self.buffer.extend(list(str(obj)))
      
  def append(self, obj):
      if isinstance(obj, StringType):
          self.buffer.extend(list(obj))
      else:
          self.buffer.extend(list(str(obj)))
      
  def charAt(self, index):
      return self.buffer[index]
  
  def __len__(self):
      return len(self.buffer)
  
  def __eq__(self, other):
      if type(self) != type(other):
          return False
      else:
          return (self.buffer == other.buffer)
  
  def __ne__(self, other):
      if type(self) != type(other):
          return True
      else:
          return (self.buffer != other.buffer)
        
  def clear(self):
      del self.buffer[0:len(self.buffer)]
  
  def __str__(self):
      return ''.join(self.buffer)
      
  def __repr__(self):
      return "'" + self.__str__() + "'"
  
  def substring(self, start, finish):
      return ''.join(self.buffer[start:finish])
      
  def __getitem__(self, index):
      return self.buffer[index]
      
  def __setitem__(self, index, c):
      if not(isinstance(c, StringType)):
          raise RuntimeError("Only single characters can be assigned")
      if not(len(c) == 1):
          raise RuntimeError("Only single characters can be assigned")
      self.buffer[index] = c
  
  def __iter__(self):
      return self.buffer
  
  def __getslice__(self, start, finish):
      return self.substring(start, finish)
      
  def reverse(self):
      self.buffer.reverse()
    
  def __contains__(self, c):
      if not(isinstance(c, StringType)):
          raise RuntimeError("Only single characters can be assigned")
      if not(len(c) == 1):
          raise RuntimeError("Only single characters can be assigned")
      return self.buffer.__contains__(c)
      
  def contains(self, c):
      self.__contains__(c)



############################# nodes.py ############################################## 

class Node(object):
    def __init__(self):
        if self.__class__ is Node:
            raise TypeError("Node class can not be instantiated.")
        self.parent = None

    def clone(self):
        abstract()
		
    def getparent(self):
        return self.parent

    def setparent(self, parent):
        self.parent = parent

    def removeChild(self, child):
    	abstract()
    	
    def replaceChild(self, oldChild, newChild):
    	abstract()

    def replaceBy(self, node):
        if (self.parent != None):
            self.parent.replaceChild(self, node)

    def toString(self, other):
        if isinstance(other, ListType):
            sb = StringBuffer()

            for node in other:
                s.append(node)

            return str(sb)
        
        if (other != None):
            return str(other)

        return ''
        
    def cloneNode(self, node):
        if(node != None):
            return node.clone()

        return None

    def cloneList(self, lst):
        clone = list()

        for node in lst:
            clone.append(node.clone())

        return clone

    def apply(self, analysis):
        abstract()

class Token(Node):
    def __init__(self):
        super(Token, self).__init__()
        self.text = None
        self.line = 0
        self.pos = 0

    def getText(self):
        return self.text

    def setText(self, text):
        self.text = text

    def getLine(self):
        return self.line

    def setLine(self, line):
        self.line = line

    def getPos(self):
        return self.pos

    def setPos(self, pos):
        self.pos = pos

    def __str__(self):
        return self.text + " "
    
    def removeChild(self, child):
        pass
      
    def replaceChild(self, oldChild,  newChild):
        pass
      

class TLeftParen(Token):
    TokenIndex = 4
    
    def __init__(self, line=0, pos=0):
        super(TLeftParen, self).__init__()
        super(TLeftParen, self).setText("(")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TLeftParen(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTLeftParen(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TLeftParen text.")


class TRightParen(Token):
    TokenIndex = 5
    
    def __init__(self, line=0, pos=0):
        super(TRightParen, self).__init__()
        super(TRightParen, self).setText(")")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TRightParen(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTRightParen(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TRightParen text.")


class TLeftBracket(Token):
    TokenIndex = 6
    
    def __init__(self, line=0, pos=0):
        super(TLeftBracket, self).__init__()
        super(TLeftBracket, self).setText("[")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TLeftBracket(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTLeftBracket(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TLeftBracket text.")


class TRightBracket(Token):
    TokenIndex = 7
    
    def __init__(self, line=0, pos=0):
        super(TRightBracket, self).__init__()
        super(TRightBracket, self).setText("]")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TRightBracket(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTRightBracket(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TRightBracket text.")


class TLeftBrace(Token):
    TokenIndex = 8
    
    def __init__(self, line=0, pos=0):
        super(TLeftBrace, self).__init__()
        super(TLeftBrace, self).setText("{")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TLeftBrace(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTLeftBrace(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TLeftBrace text.")


class TRightBrace(Token):
    TokenIndex = 9
    
    def __init__(self, line=0, pos=0):
        super(TRightBrace, self).__init__()
        super(TRightBrace, self).setText("}")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TRightBrace(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTRightBrace(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TRightBrace text.")


class TQuoteChar(Token):
    TokenIndex = 11
    
    def __init__(self, line=0, pos=0):
        super(TQuoteChar, self).__init__()
        super(TQuoteChar, self).setText("`")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
      return TQuoteChar(self.getLine(), self.getPos())

    def __copy__(self):
        return self.clone()
        
    def apply(self, analysis):
        analysis.caseTQuoteChar(self)

    def setText(self, text):
        raise RuntimeError("Cannot change TQuoteChar text.")


class TBlank(Token):
    TokenIndex = -1
        
    def __init__(self, text, line=0, pos=0):
        super(TBlank, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TBlank(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTBlank(self)
      
class TInteger(Token):
    TokenIndex = 0
    
    def __init__(self, text, line=0, pos=0):
        super(TInteger, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TInteger(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTInteger(self)
      
class TFloat(Token):
    TokenIndex = 1
    
    def __init__(self, text, line=0, pos=0):
        super(TFloat, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TFloat(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTFloat(self)
      
class THexNumber(Token):
    TokenIndex = 2
    
    def __init__(self, text, line=0, pos=0):
        super(THexNumber, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return THexNumber(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTHexNumber(self)
      
class TString(Token):
    TokenIndex = 3
    
    def __init__(self, text, line=0, pos=0):
        super(TString, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TString(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTString(self)
      
class TIdentifier(Token):
    TokenIndex = 10
    
    def __init__(self, text, line=0, pos=0):
        super(TIdentifier, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TIdentifier(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTIdentifier(self)
      
class TComment(Token):
    TokenIndex = -1
        
    def __init__(self, text, line=0, pos=0):
        super(TComment, self).__init__()    
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)
        
    def clone(self):
      return TComment(self.getText(), self.getLine(), self.getPos())

    def apply(self, analysis):
       analysis.caseTComment(self)
      

class EOF(Token):
    TokenIndex = 12

    def __init__(self, line=0, pos=0):
        super(EOF, self).__init__()    
        self.setText("")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return EOF(self.getLine(), self.getPos())

    def apply(self, analysis):
        analysis.caseEOF(self)


class AProgram(Node):
    def __init__ (self, _atom_=None):
        super(AProgram, self).__init__()
        self._atom_ = list()
        if (_atom_ != None):
            self._atom_.extend(_atom_)

    def clone(self):
        return AProgram(self.cloneList(self._atom_))

    def apply(self, analysis):
        analysis.caseAProgram(self)

    def getAtom(self):
        return self._atom_

    def setAtom(self, lst):
        del self._atom_[0:len(self._atom_)]
        self._atom_.extend(lst)
        

    def __str__(self):
        return '' + self.toString(self._atom_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if child in self._atom_:
            self._atom_.remove(child)
            return

    def replaceChild(self, oldChild, newChild):
        for i in range(self._atom_):
            if (self._atom_[i] == oldChild):
                if (newChild != None):
                    self._atom_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._atom_[i]
                oldChild.setparent(None)
                return

class AList(Node):
    def __init__ (self, _left_paren_=None,_atom_=None,_right_paren_=None):
        super(AList, self).__init__()
        self._left_paren_ = None
        self._atom_ = list()
        self._right_paren_ = None
        if (_left_paren_ != None):
            self.setLeftParen(_left_paren_)
        if (_atom_ != None):
            self._atom_.extend(_atom_)
        if (_right_paren_ != None):
            self.setRightParen(_right_paren_)

    def clone(self):
        return AList(self.cloneNode(self._left_paren_),self.cloneList(self._atom_),self.cloneNode(self._right_paren_))

    def apply(self, analysis):
        analysis.caseAList(self)

    def getLeftParen (self):
        return self._left_paren_

    def setLeftParen(self, node):
        if(self._left_paren_ != None):
            self._left_paren_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._left_paren_ = node
    def getAtom(self):
        return self._atom_

    def setAtom(self, lst):
        del self._atom_[0:len(self._atom_)]
        self._atom_.extend(lst)
        
    def getRightParen (self):
        return self._right_paren_

    def setRightParen(self, node):
        if(self._right_paren_ != None):
            self._right_paren_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._right_paren_ = node

    def __str__(self):
        return '' + self.toString(self._left_paren_)+ self.toString(self._atom_)+ self.toString(self._right_paren_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._left_paren_ == child):
            self._left_paren_ = None
            return
        if child in self._atom_:
            self._atom_.remove(child)
            return
        if (self._right_paren_ == child):
            self._right_paren_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._left_paren_ == oldChild):
            self.setLeftParen(newChild)
            return
        for i in range(self._atom_):
            if (self._atom_[i] == oldChild):
                if (newChild != None):
                    self._atom_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._atom_[i]
                oldChild.setparent(None)
                return
        if (self._right_paren_ == oldChild):
            self.setRightParen(newChild)
            return

class AVector(Node):
    def __init__ (self, _left_bracket_=None,_atom_=None,_right_bracket_=None):
        super(AVector, self).__init__()
        self._left_bracket_ = None
        self._atom_ = list()
        self._right_bracket_ = None
        if (_left_bracket_ != None):
            self.setLeftBracket(_left_bracket_)
        if (_atom_ != None):
            self._atom_.extend(_atom_)
        if (_right_bracket_ != None):
            self.setRightBracket(_right_bracket_)

    def clone(self):
        return AVector(self.cloneNode(self._left_bracket_),self.cloneList(self._atom_),self.cloneNode(self._right_bracket_))

    def apply(self, analysis):
        analysis.caseAVector(self)

    def getLeftBracket (self):
        return self._left_bracket_

    def setLeftBracket(self, node):
        if(self._left_bracket_ != None):
            self._left_bracket_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._left_bracket_ = node
    def getAtom(self):
        return self._atom_

    def setAtom(self, lst):
        del self._atom_[0:len(self._atom_)]
        self._atom_.extend(lst)
        
    def getRightBracket (self):
        return self._right_bracket_

    def setRightBracket(self, node):
        if(self._right_bracket_ != None):
            self._right_bracket_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._right_bracket_ = node

    def __str__(self):
        return '' + self.toString(self._left_bracket_)+ self.toString(self._atom_)+ self.toString(self._right_bracket_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._left_bracket_ == child):
            self._left_bracket_ = None
            return
        if child in self._atom_:
            self._atom_.remove(child)
            return
        if (self._right_bracket_ == child):
            self._right_bracket_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._left_bracket_ == oldChild):
            self.setLeftBracket(newChild)
            return
        for i in range(self._atom_):
            if (self._atom_[i] == oldChild):
                if (newChild != None):
                    self._atom_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._atom_[i]
                oldChild.setparent(None)
                return
        if (self._right_bracket_ == oldChild):
            self.setRightBracket(newChild)
            return

class ADict(Node):
    def __init__ (self, _left_brace_=None,_atom_=None,_right_brace_=None):
        super(ADict, self).__init__()
        self._left_brace_ = None
        self._atom_ = list()
        self._right_brace_ = None
        if (_left_brace_ != None):
            self.setLeftBrace(_left_brace_)
        if (_atom_ != None):
            self._atom_.extend(_atom_)
        if (_right_brace_ != None):
            self.setRightBrace(_right_brace_)

    def clone(self):
        return ADict(self.cloneNode(self._left_brace_),self.cloneList(self._atom_),self.cloneNode(self._right_brace_))

    def apply(self, analysis):
        analysis.caseADict(self)

    def getLeftBrace (self):
        return self._left_brace_

    def setLeftBrace(self, node):
        if(self._left_brace_ != None):
            self._left_brace_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._left_brace_ = node
    def getAtom(self):
        return self._atom_

    def setAtom(self, lst):
        del self._atom_[0:len(self._atom_)]
        self._atom_.extend(lst)
        
    def getRightBrace (self):
        return self._right_brace_

    def setRightBrace(self, node):
        if(self._right_brace_ != None):
            self._right_brace_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._right_brace_ = node

    def __str__(self):
        return '' + self.toString(self._left_brace_)+ self.toString(self._atom_)+ self.toString(self._right_brace_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._left_brace_ == child):
            self._left_brace_ = None
            return
        if child in self._atom_:
            self._atom_.remove(child)
            return
        if (self._right_brace_ == child):
            self._right_brace_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._left_brace_ == oldChild):
            self.setLeftBrace(newChild)
            return
        for i in range(self._atom_):
            if (self._atom_[i] == oldChild):
                if (newChild != None):
                    self._atom_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._atom_[i]
                oldChild.setparent(None)
                return
        if (self._right_brace_ == oldChild):
            self.setRightBrace(newChild)
            return

class ANumberAtom(Node):
    def __init__ (self, _number_=None):
        super(ANumberAtom, self).__init__()
        self._number_ = None
        if (_number_ != None):
            self.setNumber(_number_)

    def clone(self):
        return ANumberAtom(self.cloneNode(self._number_))

    def apply(self, analysis):
        analysis.caseANumberAtom(self)

    def getNumber (self):
        return self._number_

    def setNumber(self, node):
        if(self._number_ != None):
            self._number_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._number_ = node

    def __str__(self):
        return '' + self.toString(self._number_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._number_ == child):
            self._number_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._number_ == oldChild):
            self.setNumber(newChild)
            return

class AStringAtom(Node):
    def __init__ (self, _string_=None):
        super(AStringAtom, self).__init__()
        self._string_ = None
        if (_string_ != None):
            self.setString(_string_)

    def clone(self):
        return AStringAtom(self.cloneNode(self._string_))

    def apply(self, analysis):
        analysis.caseAStringAtom(self)

    def getString (self):
        return self._string_

    def setString(self, node):
        if(self._string_ != None):
            self._string_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._string_ = node

    def __str__(self):
        return '' + self.toString(self._string_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._string_ == child):
            self._string_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._string_ == oldChild):
            self.setString(newChild)
            return

class AListAtom(Node):
    def __init__ (self, _list_=None):
        super(AListAtom, self).__init__()
        self._list_ = None
        if (_list_ != None):
            self.setList(_list_)

    def clone(self):
        return AListAtom(self.cloneNode(self._list_))

    def apply(self, analysis):
        analysis.caseAListAtom(self)

    def getList (self):
        return self._list_

    def setList(self, node):
        if(self._list_ != None):
            self._list_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._list_ = node

    def __str__(self):
        return '' + self.toString(self._list_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._list_ == child):
            self._list_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._list_ == oldChild):
            self.setList(newChild)
            return

class AVectorAtom(Node):
    def __init__ (self, _vector_=None):
        super(AVectorAtom, self).__init__()
        self._vector_ = None
        if (_vector_ != None):
            self.setVector(_vector_)

    def clone(self):
        return AVectorAtom(self.cloneNode(self._vector_))

    def apply(self, analysis):
        analysis.caseAVectorAtom(self)

    def getVector (self):
        return self._vector_

    def setVector(self, node):
        if(self._vector_ != None):
            self._vector_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._vector_ = node

    def __str__(self):
        return '' + self.toString(self._vector_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._vector_ == child):
            self._vector_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._vector_ == oldChild):
            self.setVector(newChild)
            return

class ADictAtom(Node):
    def __init__ (self, _dict_=None):
        super(ADictAtom, self).__init__()
        self._dict_ = None
        if (_dict_ != None):
            self.setDict(_dict_)

    def clone(self):
        return ADictAtom(self.cloneNode(self._dict_))

    def apply(self, analysis):
        analysis.caseADictAtom(self)

    def getDict (self):
        return self._dict_

    def setDict(self, node):
        if(self._dict_ != None):
            self._dict_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._dict_ = node

    def __str__(self):
        return '' + self.toString(self._dict_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._dict_ == child):
            self._dict_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._dict_ == oldChild):
            self.setDict(newChild)
            return

class AIdentifierAtom(Node):
    def __init__ (self, _identifier_=None):
        super(AIdentifierAtom, self).__init__()
        self._identifier_ = None
        if (_identifier_ != None):
            self.setIdentifier(_identifier_)

    def clone(self):
        return AIdentifierAtom(self.cloneNode(self._identifier_))

    def apply(self, analysis):
        analysis.caseAIdentifierAtom(self)

    def getIdentifier (self):
        return self._identifier_

    def setIdentifier(self, node):
        if(self._identifier_ != None):
            self._identifier_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._identifier_ = node

    def __str__(self):
        return '' + self.toString(self._identifier_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._identifier_ == child):
            self._identifier_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._identifier_ == oldChild):
            self.setIdentifier(newChild)
            return

class AFloatNumber(Node):
    def __init__ (self, _float_=None):
        super(AFloatNumber, self).__init__()
        self._float_ = None
        if (_float_ != None):
            self.setFloat(_float_)

    def clone(self):
        return AFloatNumber(self.cloneNode(self._float_))

    def apply(self, analysis):
        analysis.caseAFloatNumber(self)

    def getFloat (self):
        return self._float_

    def setFloat(self, node):
        if(self._float_ != None):
            self._float_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._float_ = node

    def __str__(self):
        return '' + self.toString(self._float_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._float_ == child):
            self._float_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._float_ == oldChild):
            self.setFloat(newChild)
            return

class AIntegerNumber(Node):
    def __init__ (self, _integer_=None):
        super(AIntegerNumber, self).__init__()
        self._integer_ = None
        if (_integer_ != None):
            self.setInteger(_integer_)

    def clone(self):
        return AIntegerNumber(self.cloneNode(self._integer_))

    def apply(self, analysis):
        analysis.caseAIntegerNumber(self)

    def getInteger (self):
        return self._integer_

    def setInteger(self, node):
        if(self._integer_ != None):
            self._integer_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def __str__(self):
        return '' + self.toString(self._integer_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._integer_ == child):
            self._integer_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._integer_ == oldChild):
            self.setInteger(newChild)
            return

class AHexNumber(Node):
    def __init__ (self, _hex_number_=None):
        super(AHexNumber, self).__init__()
        self._hex_number_ = None
        if (_hex_number_ != None):
            self.setHexNumber(_hex_number_)

    def clone(self):
        return AHexNumber(self.cloneNode(self._hex_number_))

    def apply(self, analysis):
        analysis.caseAHexNumber(self)

    def getHexNumber (self):
        return self._hex_number_

    def setHexNumber(self, node):
        if(self._hex_number_ != None):
            self._hex_number_.setparent(None)

        if (node != None):
            if (node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._hex_number_ = node

    def __str__(self):
        return '' + self.toString(self._hex_number_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
    def removeChild(self, child):
        if (self._hex_number_ == child):
            self._hex_number_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if (self._hex_number_ == oldChild):
            self.setHexNumber(newChild)
            return


class Start(Node):
    def __init__(self, _base_=None, _eof_=None):
        super(Start, self).__init__()
        self._base_ = None
        self._eof_ = None
        self.setPProgram(_base_)
        self.setEOF(_eof_)

    def clone(self):
        return Start(self.cloneNode(self._base_), self.cloneNode(self._eof_))

    def apply(self, analysis):
        analysis.caseStart(self)

    def getPProgram(self):
        return self._base_
        
    def setPProgram(self, node):
        if(self._base_ != None):
            self._base_.setparent(None)

        if(node != None):
            if(node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._base_ = node

    def getEOF(self):
        return self._eof_
        
    def setEOF(self, node):
        if(self._eof_ != None):
            self._eof_.setparent(None)

        if(node != None):
            if(node.getparent() != None):
                node.getparent().removeChild(node)

            node.setparent(self)

        self._eof_ = node

    def removeChild(self, child):
        if(self._base_ == child):
            self._base_ = None
            return

        if(self._eof_ == child):
            self._eof_ = None
            return

    def replaceChild(self, oldChild, newChild):
        if(self._base_ == oldChild):
            self.setPProgram(newChild)
            return

        if(self._eof_ == oldChild):
            self.setEOF(newChild)
            return

    def __str__(self):
        return '' + self.toString(self._base_) + self.toString(self._eof_)
    
    def __repr__(self):
        return "'" + self.__str__() + "'"
        
     

############################# analysis.py #############################################

class Analysis(object):
    def __init__(self):
        self._in_ = None
        self._out_ = None

    def getIn(self, node):
        if (self._in_ == None):
            return None
            
        if self._in_.has_key(node):
            return self._in_[node]
        else:
            return None

    def setIn(self, node, _in_):
        if(self._in_ == None):
            self._in_ = dict()

        if not(_in_ == None):
            self._in_[node] = _in_
        else:
            if self._in_.has_key(node):
                del self._in_[node]

    def getOut(self, node):
        if(self._out_ == None):
            return None
            
        if self._out_.has_key(node):
            return self._out_[node]
        else:
            return None

    def setOut(self, node, _out_):
        if(self._out_ == None):
            self._out_ = dict()

        if not(_out_ == None):
            self._out_[node] = _out_
        else:
            if self._out_.has_key(node):
                del self._out_[node]

    def caseStart(self, node):
        self.defaultCase(node)

    def caseAProgram(self, node):
        self.defaultCase(node)
        
    def caseAList(self, node):
        self.defaultCase(node)
        
    def caseAVector(self, node):
        self.defaultCase(node)
        
    def caseADict(self, node):
        self.defaultCase(node)
        
    def caseANumberAtom(self, node):
        self.defaultCase(node)
        
    def caseAStringAtom(self, node):
        self.defaultCase(node)
        
    def caseAListAtom(self, node):
        self.defaultCase(node)
        
    def caseAVectorAtom(self, node):
        self.defaultCase(node)
        
    def caseADictAtom(self, node):
        self.defaultCase(node)
        
    def caseAIdentifierAtom(self, node):
        self.defaultCase(node)
        
    def caseAFloatNumber(self, node):
        self.defaultCase(node)
        
    def caseAIntegerNumber(self, node):
        self.defaultCase(node)
        
    def caseAHexNumber(self, node):
        self.defaultCase(node)
        

    def caseTBlank(self, node):
        self.defaultCase(node)
        
    def caseTInteger(self, node):
        self.defaultCase(node)
        
    def caseTFloat(self, node):
        self.defaultCase(node)
        
    def caseTHexNumber(self, node):
        self.defaultCase(node)
        
    def caseTString(self, node):
        self.defaultCase(node)
        
    def caseTLeftParen(self, node):
        self.defaultCase(node)
        
    def caseTRightParen(self, node):
        self.defaultCase(node)
        
    def caseTLeftBracket(self, node):
        self.defaultCase(node)
        
    def caseTRightBracket(self, node):
        self.defaultCase(node)
        
    def caseTLeftBrace(self, node):
        self.defaultCase(node)
        
    def caseTRightBrace(self, node):
        self.defaultCase(node)
        
    def caseTIdentifier(self, node):
        self.defaultCase(node)
        
    def caseTComment(self, node):
        self.defaultCase(node)
        
    def caseTQuoteChar(self, node):
        self.defaultCase(node)
        
    def caseEOF(self, node):
        self.defaultCase(node)

    def defaultCase(self, node):
		pass

class DepthFirstAdapter(Analysis):
    def inStart(self, node):
        self.defaultIn(node)

    def outStart(self, node):
        self.defaultOut(node)

    def defaultIn(self, node):
        pass

    def defaultOut(self, node):
	    pass

    def caseStart(self, node):
        self.inStart(node)
        node.getPProgram().apply(self)
        node.getEOF().apply(self);
        self.outStart(node)

    def inAProgram(self, node):
        self.defaultIn(node)

    def outAProgram(self, node):
        self.defaultOut(node)

    def caseAProgram(self, node):
        self.inAProgram(node)
        temp = node.getAtom()
        for item in temp:
            item.apply(self)
        self.outAProgram(node)
        
    def inAList(self, node):
        self.defaultIn(node)

    def outAList(self, node):
        self.defaultOut(node)

    def caseAList(self, node):
        self.inAList(node)
        if not(node.getLeftParen() == None):
            node.getLeftParen().apply(self)
        temp = node.getAtom()
        for item in temp:
            item.apply(self)
        if not(node.getRightParen() == None):
            node.getRightParen().apply(self)
        self.outAList(node)
        
    def inAVector(self, node):
        self.defaultIn(node)

    def outAVector(self, node):
        self.defaultOut(node)

    def caseAVector(self, node):
        self.inAVector(node)
        if not(node.getLeftBracket() == None):
            node.getLeftBracket().apply(self)
        temp = node.getAtom()
        for item in temp:
            item.apply(self)
        if not(node.getRightBracket() == None):
            node.getRightBracket().apply(self)
        self.outAVector(node)
        
    def inADict(self, node):
        self.defaultIn(node)

    def outADict(self, node):
        self.defaultOut(node)

    def caseADict(self, node):
        self.inADict(node)
        if not(node.getLeftBrace() == None):
            node.getLeftBrace().apply(self)
        temp = node.getAtom()
        for item in temp:
            item.apply(self)
        if not(node.getRightBrace() == None):
            node.getRightBrace().apply(self)
        self.outADict(node)
        
    def inANumberAtom(self, node):
        self.defaultIn(node)

    def outANumberAtom(self, node):
        self.defaultOut(node)

    def caseANumberAtom(self, node):
        self.inANumberAtom(node)
        if not(node.getNumber() == None):
            node.getNumber().apply(self)
        self.outANumberAtom(node)
        
    def inAStringAtom(self, node):
        self.defaultIn(node)

    def outAStringAtom(self, node):
        self.defaultOut(node)

    def caseAStringAtom(self, node):
        self.inAStringAtom(node)
        if not(node.getString() == None):
            node.getString().apply(self)
        self.outAStringAtom(node)
        
    def inAListAtom(self, node):
        self.defaultIn(node)

    def outAListAtom(self, node):
        self.defaultOut(node)

    def caseAListAtom(self, node):
        self.inAListAtom(node)
        if not(node.getList() == None):
            node.getList().apply(self)
        self.outAListAtom(node)
        
    def inAVectorAtom(self, node):
        self.defaultIn(node)

    def outAVectorAtom(self, node):
        self.defaultOut(node)

    def caseAVectorAtom(self, node):
        self.inAVectorAtom(node)
        if not(node.getVector() == None):
            node.getVector().apply(self)
        self.outAVectorAtom(node)
        
    def inADictAtom(self, node):
        self.defaultIn(node)

    def outADictAtom(self, node):
        self.defaultOut(node)

    def caseADictAtom(self, node):
        self.inADictAtom(node)
        if not(node.getDict() == None):
            node.getDict().apply(self)
        self.outADictAtom(node)
        
    def inAIdentifierAtom(self, node):
        self.defaultIn(node)

    def outAIdentifierAtom(self, node):
        self.defaultOut(node)

    def caseAIdentifierAtom(self, node):
        self.inAIdentifierAtom(node)
        if not(node.getIdentifier() == None):
            node.getIdentifier().apply(self)
        self.outAIdentifierAtom(node)
        
    def inAFloatNumber(self, node):
        self.defaultIn(node)

    def outAFloatNumber(self, node):
        self.defaultOut(node)

    def caseAFloatNumber(self, node):
        self.inAFloatNumber(node)
        if not(node.getFloat() == None):
            node.getFloat().apply(self)
        self.outAFloatNumber(node)
        
    def inAIntegerNumber(self, node):
        self.defaultIn(node)

    def outAIntegerNumber(self, node):
        self.defaultOut(node)

    def caseAIntegerNumber(self, node):
        self.inAIntegerNumber(node)
        if not(node.getInteger() == None):
            node.getInteger().apply(self)
        self.outAIntegerNumber(node)
        
    def inAHexNumber(self, node):
        self.defaultIn(node)

    def outAHexNumber(self, node):
        self.defaultOut(node)

    def caseAHexNumber(self, node):
        self.inAHexNumber(node)
        if not(node.getHexNumber() == None):
            node.getHexNumber().apply(self)
        self.outAHexNumber(node)
        


class ReversedDepthFirstAdapter(Analysis):
    def inStart(self, node):
        self.defaultIn(node)

    def outStart(self, node):
        self.defaultOut(node)

    def defaultIn(self, node):
        pass

    def defaultOut(self, node):
        pass

    def caseStart(self, node):
        self.inStart(node)
        node.getEOF().apply(self)
        node.getPProgram().apply(self)
        self.outStart(node)

    def inAProgram(self, node):
        self.defaultIn(node)

    def outAProgram(self, node):
        self.defaultOut(node)

    def caseAProgram(self, node):
        self.inAProgram(node)
        temp = node.getAtom()
        temp.reverse()
        for item in temp:
            item.apply(self)
        self.outAProgram(node)
        
    def inAList(self, node):
        self.defaultIn(node)

    def outAList(self, node):
        self.defaultOut(node)

    def caseAList(self, node):
        self.inAList(node)
        if (node.getRightParen() != None):
            node.getRightParen().apply(self)
        temp = node.getAtom()
        temp.reverse()
        for item in temp:
            item.apply(self)
        if (node.getLeftParen() != None):
            node.getLeftParen().apply(self)
        self.outAList(node)
        
    def inAVector(self, node):
        self.defaultIn(node)

    def outAVector(self, node):
        self.defaultOut(node)

    def caseAVector(self, node):
        self.inAVector(node)
        if (node.getRightBracket() != None):
            node.getRightBracket().apply(self)
        temp = node.getAtom()
        temp.reverse()
        for item in temp:
            item.apply(self)
        if (node.getLeftBracket() != None):
            node.getLeftBracket().apply(self)
        self.outAVector(node)
        
    def inADict(self, node):
        self.defaultIn(node)

    def outADict(self, node):
        self.defaultOut(node)

    def caseADict(self, node):
        self.inADict(node)
        if (node.getRightBrace() != None):
            node.getRightBrace().apply(self)
        temp = node.getAtom()
        temp.reverse()
        for item in temp:
            item.apply(self)
        if (node.getLeftBrace() != None):
            node.getLeftBrace().apply(self)
        self.outADict(node)
        
    def inANumberAtom(self, node):
        self.defaultIn(node)

    def outANumberAtom(self, node):
        self.defaultOut(node)

    def caseANumberAtom(self, node):
        self.inANumberAtom(node)
        if (node.getNumber() != None):
            node.getNumber().apply(self)
        self.outANumberAtom(node)
        
    def inAStringAtom(self, node):
        self.defaultIn(node)

    def outAStringAtom(self, node):
        self.defaultOut(node)

    def caseAStringAtom(self, node):
        self.inAStringAtom(node)
        if (node.getString() != None):
            node.getString().apply(self)
        self.outAStringAtom(node)
        
    def inAListAtom(self, node):
        self.defaultIn(node)

    def outAListAtom(self, node):
        self.defaultOut(node)

    def caseAListAtom(self, node):
        self.inAListAtom(node)
        if (node.getList() != None):
            node.getList().apply(self)
        self.outAListAtom(node)
        
    def inAVectorAtom(self, node):
        self.defaultIn(node)

    def outAVectorAtom(self, node):
        self.defaultOut(node)

    def caseAVectorAtom(self, node):
        self.inAVectorAtom(node)
        if (node.getVector() != None):
            node.getVector().apply(self)
        self.outAVectorAtom(node)
        
    def inADictAtom(self, node):
        self.defaultIn(node)

    def outADictAtom(self, node):
        self.defaultOut(node)

    def caseADictAtom(self, node):
        self.inADictAtom(node)
        if (node.getDict() != None):
            node.getDict().apply(self)
        self.outADictAtom(node)
        
    def inAIdentifierAtom(self, node):
        self.defaultIn(node)

    def outAIdentifierAtom(self, node):
        self.defaultOut(node)

    def caseAIdentifierAtom(self, node):
        self.inAIdentifierAtom(node)
        if (node.getIdentifier() != None):
            node.getIdentifier().apply(self)
        self.outAIdentifierAtom(node)
        
    def inAFloatNumber(self, node):
        self.defaultIn(node)

    def outAFloatNumber(self, node):
        self.defaultOut(node)

    def caseAFloatNumber(self, node):
        self.inAFloatNumber(node)
        if (node.getFloat() != None):
            node.getFloat().apply(self)
        self.outAFloatNumber(node)
        
    def inAIntegerNumber(self, node):
        self.defaultIn(node)

    def outAIntegerNumber(self, node):
        self.defaultOut(node)

    def caseAIntegerNumber(self, node):
        self.inAIntegerNumber(node)
        if (node.getInteger() != None):
            node.getInteger().apply(self)
        self.outAIntegerNumber(node)
        
    def inAHexNumber(self, node):
        self.defaultIn(node)

    def outAHexNumber(self, node):
        self.defaultOut(node)

    def caseAHexNumber(self, node):
        self.inAHexNumber(node)
        if (node.getHexNumber() != None):
            node.getHexNumber().apply(self)
        self.outAHexNumber(node)
        


############################# lexer.py ############################################# 

class LexerException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value
        
# lexer states
STATE_INITIAL = 0

accept_tokens = [None] * 14
        
accept_tokens[0] = lambda line, pos: TBlank(None, line, pos)
accept_tokens[1] = lambda line, pos: TInteger(None, line, pos)
accept_tokens[2] = lambda line, pos: TFloat(None, line, pos)
accept_tokens[3] = lambda line, pos: THexNumber(None, line, pos)
accept_tokens[4] = lambda line, pos: TString(None, line, pos)
accept_tokens[5] = lambda line, pos: TLeftParen(line, pos)
accept_tokens[6] = lambda line, pos: TRightParen(line, pos)
accept_tokens[7] = lambda line, pos: TLeftBracket(line, pos)
accept_tokens[8] = lambda line, pos: TRightBracket(line, pos)
accept_tokens[9] = lambda line, pos: TLeftBrace(line, pos)
accept_tokens[10] = lambda line, pos: TRightBrace(line, pos)
accept_tokens[11] = lambda line, pos: TIdentifier(None, line, pos)
accept_tokens[12] = lambda line, pos: TComment(None, line, pos)
accept_tokens[13] = lambda line, pos: TQuoteChar(line, pos)


lexer_gotoTable = [
                    [
                      [
                        [9, 9, 1],
                        [10, 10, 2],
                        [13, 13, 3],
                        [32, 32, 4],
                        [33, 33, 5],
                        [34, 34, 6],
                        [39, 39, 7],
                        [40, 40, 8],
                        [41, 41, 9],
                        [42, 42, 10],
                        [43, 43, 11],
                        [45, 45, 12],
                        [46, 46, 13],
                        [48, 48, 14],
                        [49, 57, 15],
                        [59, 59, 16],
                        [60, 60, 17],
                        [61, 61, 18],
                        [62, 62, 19],
                        [63, 63, 20],
                        [65, 90, 21],
                        [91, 91, 22],
                        [93, 93, 23],
                        [95, 95, 24],
                        [96, 96, 25],
                        [97, 122, 26],
                        [123, 123, 27],
                        [125, 125, 28],
                      ],
                      [
                        [9, 32, -2],
                      ],
                      [
                        [9, 32, -2],
                      ],
                      [
                        [9, 9, 1],
                        [10, 10, 29],
                        [13, 32, -2],
                      ],
                      [
                        [9, 32, -2],
                      ],
                      [
                        [33, 33, 5],
                        [39, 39, 7],
                        [42, 43, -2],
                        [45, 45, 30],
                        [46, 46, 13],
                        [48, 57, 31],
                        [60, 90, -2],
                        [95, 95, 24],
                        [97, 122, 26],
                      ],
                      [
                        [0, 33, 32],
                        [34, 34, 33],
                        [35, 65535, 32],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 46, -7],
                        [48, 57, 15],
                        [60, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 45, -7],
                        [46, 46, 34],
                        [48, 63, -14],
                        [65, 87, 21],
                        [88, 88, 35],
                        [89, 90, 21],
                        [95, 95, 24],
                        [97, 119, 26],
                        [120, 120, 36],
                        [121, 122, 26],
                      ],
                      [
                        [33, 63, -16],
                        [65, 122, -7],
                      ],
                      [
                        [0, 9, 37],
                        [11, 12, 37],
                        [14, 65535, 37],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                      ],
                      [
                      ],
                      [
                        [9, 32, -2],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [33, 122, -7],
                      ],
                      [
                        [0, 65535, -8],
                      ],
                      [
                      ],
                      [
                        [33, 46, -7],
                        [48, 57, 38],
                        [60, 122, -7],
                      ],
                      [
                        [33, 46, -7],
                        [48, 57, 39],
                        [60, 95, -7],
                        [97, 102, 40],
                        [103, 122, 26],
                      ],
                      [
                        [33, 122, -37],
                      ],
                      [
                        [0, 65535, -18],
                      ],
                      [
                        [33, 122, -36],
                      ],
                      [
                        [33, 122, -37],
                      ],
                      [
                        [33, 122, -37],
                      ],
                    ],
                  ] 
                
accept_table = [
                 [
                   0, 0, 0, 0, 0, 11, -1, 11, 5, 6, 11, 11, 11, 11, 1, 1, 12, 11, 11, 11, 11, 11, 7, 8, 11, 13, 11, 9, 10, 0, 11, 11, -1, 4, 11, 11, 11, 12, 2, 3, 3, 
                 ],
               ]
             
class Lexer(object):
    def __init__(self, source):
        if isinstance(source, StringType):
            self.reader = PushbackReader(file(source, "r"))
        else:
            self.reader = PushbackReader(source)

        self.token = None
        self.state = STATE_INITIAL
        self.line = 0
        self.pos = 0
        self.cr = False
        self.eof = False
        self.text = StringBuffer()

    def filter(self):
        pass

    def peek(self):
        while(self.token == None):
            self.token = self.getToken()
            self.filter()
        return self.token

    def next(self):
        while (self.token == None):
            self.token = self.getToken()
            self.filter()

        result = self.token
        self.token = None
        return result

    def getToken(self):
        dfa_state = 0

        start_pos = self.pos
        start_line = self.line

        accept_state = -1
        accept_token = -1
        accept_length = -1
        accept_pos = -1
        accept_line = -1
        gotoTable = lexer_gotoTable[self.state]
        accept = accept_table[self.state]
        text = self.text
        text.clear()

        while 1:
            c = self.getChar()

            if(c != -1):
                if (c == 10):
                    if(self.cr):
                        self.cr = False
                    else:
                        self.line = self.line + 1
                        self.pos = 0
                elif (c == 13):
                    self.line = self.line + 1
                    self.pos = 0
                    self.cr = True
                else:
                    self.pos = self.pos + 1
                    self.cr = False

                text.append(chr(c))
                
                while 1:
                    if (dfa_state < -1):
                        oldState = (-2 -dfa_state)
                    else:
                        oldState = dfa_state

                    dfa_state = -1

                    tmp1 =  gotoTable[oldState]
                    low = 0
                    high = len(tmp1) - 1

                    while (low <= high):
                        middle = (low + high) / 2
                        tmp2 = tmp1[middle]

                        if(c < tmp2[0]):
                            high = middle - 1
                        elif (c > tmp2[1]):
                            low = middle + 1
                        else:
                            dfa_state = tmp2[2]
                            break
                    if (dfa_state >= -1):
                    	break
            else:
                dfa_state = -1

            if (dfa_state >= 0):
                if (accept[dfa_state] != -1):
                    accept_state = dfa_state
                    accept_token = accept[dfa_state]
                    accept_length = len(text)
                    accept_pos = self.pos
                    accept_line = self.line
            else:
                if (accept_state != -1):
                    if (accept_token >= 0 and accept_token <= 13):
                    	token = accept_tokens[accept_token](start_line + 1, start_pos + 1)
                    	if token.getText() == None:
                    	    token.setText(self.getText(accept_length))
                    	
                        self.pushBack(accept_length)
                        self.pos = accept_pos
                        self.line = accept_line
                      
                        return token
                else:
                    if (len(text) > 0):
                        raise LexerException("[" + str(start_line + 1) + "," + str(start_pos + 1) + "]" +" Unknown token: " + str(text))
                    else:
                        return EOF(start_line + 1, start_pos + 1)

    def getChar(self):
        if (self.eof):
            return -1
        c = self.reader.read()
        
        if (c == ""):
            result = -1
        else:
            result = ord(c)

        if(result == -1):
            self.eof = True

        return result

    def pushBack(self, acceptLength):
        text = self.text
        length = len(text)
        for i in range(length - 1, acceptLength - 1, -1):
            self.eof = False
            self.reader.unread(text.charAt(i))

    def unread(self, token):
        text = token.getText()
        length = len(text)

        for i in range(length-1, -1, -1):
            self.eof = False
            self.reader.unread(text[i])

        self.pos = token.getPos() - 1
        self.line = token.getLine() - 1

    def getText(self, acceptLength):
        sb = StringBuffer()
        text = self.text
        for i in range(acceptLength):
            sb.append(text.charAt(i))

        return str(sb)

############################# parser.py #############################################

class ParserException(Exception):
    def __init__(self, token, value):
        self.value = value
        self.token = token

    def getToken(self):
        return self.token

    def __str__(self):
        return self.value
        
class State(object):
    def __init__(self, state, nodes):
        self.state = state
        self.nodes = nodes

# parser actions
ACTION_SHIFT = 0
ACTION_REDUCE = 1
ACTION_ACCEPT = 2
ACTION_ERROR = 3
        
def new0(self):
    nodeList = list()
    listNode2 = list()
    pprogramNode1 = AProgram(listNode2)
    nodeList.append(pprogramNode1)
    return nodeList, 0

def new1(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode2 = nodeArrayList1[0]
    if (listNode2 != None):
        listNode3.extend(listNode2)
    pprogramNode1 = AProgram(listNode3)
    nodeList.append(pprogramNode1)
    return nodeList, 0

def new2(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    tleftparenNode2 = nodeArrayList1[0]
    trightparenNode4 = nodeArrayList2[0]
    plistNode1 = AList(tleftparenNode2,listNode3,trightparenNode4)
    nodeList.append(plistNode1)
    return nodeList, 1

def new3(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode4 = list()
    tleftparenNode2 = nodeArrayList1[0]
    listNode3 = nodeArrayList2[0]
    if (listNode3 != None):
        listNode4.extend(listNode3)
    trightparenNode5 = nodeArrayList3[0]
    plistNode1 = AList(tleftparenNode2,listNode4,trightparenNode5)
    nodeList.append(plistNode1)
    return nodeList, 1

def new4(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    tleftbracketNode2 = nodeArrayList1[0]
    trightbracketNode4 = nodeArrayList2[0]
    pvectorNode1 = AVector(tleftbracketNode2,listNode3,trightbracketNode4)
    nodeList.append(pvectorNode1)
    return nodeList, 2

def new5(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode4 = list()
    tleftbracketNode2 = nodeArrayList1[0]
    listNode3 = nodeArrayList2[0]
    if (listNode3 != None):
        listNode4.extend(listNode3)
    trightbracketNode5 = nodeArrayList3[0]
    pvectorNode1 = AVector(tleftbracketNode2,listNode4,trightbracketNode5)
    nodeList.append(pvectorNode1)
    return nodeList, 2

def new6(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    tleftbraceNode2 = nodeArrayList1[0]
    trightbraceNode4 = nodeArrayList2[0]
    pdictNode1 = ADict(tleftbraceNode2,listNode3,trightbraceNode4)
    nodeList.append(pdictNode1)
    return nodeList, 3

def new7(self):
    nodeList = list()
    nodeArrayList3 = self.pop()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode4 = list()
    tleftbraceNode2 = nodeArrayList1[0]
    listNode3 = nodeArrayList2[0]
    if (listNode3 != None):
        listNode4.extend(listNode3)
    trightbraceNode5 = nodeArrayList3[0]
    pdictNode1 = ADict(tleftbraceNode2,listNode4,trightbraceNode5)
    nodeList.append(pdictNode1)
    return nodeList, 3

def new8(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    pnumberNode2 = nodeArrayList1[0]
    patomNode1 = ANumberAtom(pnumberNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new9(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    tstringNode2 = nodeArrayList1[0]
    patomNode1 = AStringAtom(tstringNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new10(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    plistNode2 = nodeArrayList1[0]
    patomNode1 = AListAtom(plistNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new11(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    pvectorNode2 = nodeArrayList1[0]
    patomNode1 = AVectorAtom(pvectorNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new12(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    pdictNode2 = nodeArrayList1[0]
    patomNode1 = ADictAtom(pdictNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new13(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    tidentifierNode2 = nodeArrayList1[0]
    patomNode1 = AIdentifierAtom(tidentifierNode2)
    nodeList.append(patomNode1)
    return nodeList, 4

def new14(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    tfloatNode2 = nodeArrayList1[0]
    pnumberNode1 = AFloatNumber(tfloatNode2)
    nodeList.append(pnumberNode1)
    return nodeList, 5

def new15(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    tintegerNode2 = nodeArrayList1[0]
    pnumberNode1 = AIntegerNumber(tintegerNode2)
    nodeList.append(pnumberNode1)
    return nodeList, 5

def new16(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    thexnumberNode2 = nodeArrayList1[0]
    pnumberNode1 = AHexNumber(thexnumberNode2)
    nodeList.append(pnumberNode1)
    return nodeList, 5

def new17(self):
    nodeList = list()
    nodeArrayList1 = self.pop()
    listNode2 = list()
    patomNode1 = nodeArrayList1[0]
    if (patomNode1 != None):
        listNode2.append(patomNode1)
    nodeList.append(listNode2)
    return nodeList, 6

def new18(self):
    nodeList = list()
    nodeArrayList2 = self.pop()
    nodeArrayList1 = self.pop()
    listNode3 = list()
    listNode1 = nodeArrayList1[0]
    patomNode2 = nodeArrayList2[0]
    if (listNode1 != None):
        listNode3.extend(listNode1)
    if (patomNode2 != None):
        listNode3.append(patomNode2)
    nodeList.append(listNode3)
    return nodeList, 6

newnode = [
  new0,
  new1,
  new2,
  new3,
  new4,
  new5,
  new6,
  new7,
  new8,
  new9,
  new10,
  new11,
  new12,
  new13,
  new14,
  new15,
  new16,
  new17,
  new18
]

actionTable = [
                [
                  [-1, 1, 0],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 15],
                ],
                [
                  [-1, 1, 14],
                ],
                [
                  [-1, 1, 16],
                ],
                [
                  [-1, 1, 9],
                ],
                [
                  [-1, 3, 5],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [5, 0, 16],
                  [6, 0, 6],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 3, 6],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [7, 0, 18],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 3, 7],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [8, 0, 7],
                  [9, 0, 20],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 13],
                ],
                [
                  [-1, 3, 9],
                  [12, 2, -1],
                ],
                [
                  [-1, 1, 10],
                ],
                [
                  [-1, 1, 11],
                ],
                [
                  [-1, 1, 12],
                ],
                [
                  [-1, 1, 17],
                ],
                [
                  [-1, 1, 8],
                ],
                [
                  [-1, 1, 1],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 2],
                ],
                [
                  [-1, 3, 17],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [5, 0, 23],
                  [6, 0, 6],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 4],
                ],
                [
                  [-1, 3, 19],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [7, 0, 24],
                  [8, 0, 7],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 6],
                ],
                [
                  [-1, 3, 21],
                  [0, 0, 1],
                  [1, 0, 2],
                  [2, 0, 3],
                  [3, 0, 4],
                  [4, 0, 5],
                  [6, 0, 6],
                  [8, 0, 7],
                  [9, 0, 25],
                  [10, 0, 8],
                ],
                [
                  [-1, 1, 18],
                ],
                [
                  [-1, 1, 3],
                ],
                [
                  [-1, 1, 5],
                ],
                [
                  [-1, 1, 7],
                ],
              ]

parser_gotoTable = [
                     [
                       [-1, 9],
                     ],
                     [
                       [-1, 10],
                     ],
                     [
                       [-1, 11],
                     ],
                     [
                       [-1, 12],
                     ],
                     [
                       [-1, 13],
                       [15, 22],
                       [17, 22],
                       [19, 22],
                       [21, 22],
                     ],
                     [
                       [-1, 14],
                     ],
                     [
                       [-1, 15],
                       [5, 17],
                       [6, 19],
                       [7, 21],
                     ],
                   ]
    
errorMessages = [
                  "expecting: integer, float, hex number, string, '(', '[', '{', identifier, EOF",
                  "expecting: integer, float, hex number, string, '(', ')', '[', ']', '{', '}', identifier, EOF",
                  "expecting: integer, float, hex number, string, '(', ')', '[', '{', identifier",
                  "expecting: integer, float, hex number, string, '(', '[', ']', '{', identifier",
                  "expecting: integer, float, hex number, string, '(', '[', '{', '}', identifier",
                  "expecting: EOF",
                ]
    
errors = [
           0, 1, 1, 1, 1, 2, 3, 4, 1, 5, 1, 1, 1, 1, 1, 0, 1, 2, 1, 3, 1, 4, 1, 1, 1, 1, 
         ]
                                   
class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        self.stack = Stack()
     
    def goTo(self, index):
        state = self.state()
        low = 1
        high = len(parser_gotoTable[index]) - 1
        value = parser_gotoTable[index][0][1]

        while (low <= high):
            middle = (low + high) / 2

            if (state < parser_gotoTable[index][middle][0]):
                high = middle - 1
            elif (state > parser_gotoTable[index][middle][0]):
                low = middle + 1
            else:
                value = parser_gotoTable[index][middle][1]
                break

        return value

    def push(self, numstate, listNode):
        self.stack.push(State(numstate, listNode))

    def state(self):
        return self.stack.peek().state

    def pop(self):
        return self.stack.pop().nodes

    def parse(self):
        self.push(0, None)
        lexer = self.lexer
        last_shift = 0
        last_pos = 0
        last_line = 0
        last_token = None
        action = [0,0]
        
        while 1:
            while (lexer.peek().TokenIndex == -1):
                lexer.next()

            token = lexer.peek()
            last_pos = token.getPos()
            last_line = token.getLine()
            last_token = token

            index = token.TokenIndex
            action[0] = actionTable[self.state()][0][1]
            action[1] = actionTable[self.state()][0][2]

            low = 1
            high = len(actionTable[self.state()]) - 1

            while (low <= high):
                middle = (low + high) / 2

                if (index < actionTable[self.state()][middle][0]):
                    high = middle - 1
                elif (index > actionTable[self.state()][middle][0]):
                    low = middle + 1
                else:
                    action[0] = actionTable[self.state()][middle][1]
                    action[1] = actionTable[self.state()][middle][2]
                    break

            if (action[0] == ACTION_SHIFT):
                nodeList = list()
                nodeList.append(lexer.next())
                self.push(action[1], nodeList)
                last_shift = action[1]
            elif (action[0] == ACTION_REDUCE):
                if (action[1] >= 0 and action[1] <= 18):
                    nodeList, leftside = newnode[action[1]](self)
                    self.push(self.goTo(leftside), nodeList)
            elif (action[0] == ACTION_ACCEPT):
                node2 = lexer.next()
                node1 = self.pop()[0]
                node = Start(node1, node2)
                return node
            elif (action[0] == ACTION_ERROR):
                raise ParserException(last_token, "[" + str(last_line) + "," + str(last_pos) + "] " + errorMessages[errors[action[1]]])
    
    def unescape (self, s):
        _out_ = StringBuffer()
      
        for i in range(len(s)):
            c = s[i]

            if (c == '\\'):
                if ((i + 1) < len(s)):
                    i += 1
                    if (s[i] == 'n'):
                        _out_.append ("\n")
                    elif (s[i] == 'r'):
                        _out_.append("\r")
                    elif (s[i] == '"'):
                        _out_.append ("\"");
                    elif (s[i] == '\\'):
                        _out_.append ("\\");
                    elif (s[i] == '0'):
                        if (s[i:].startswith("000")):
                            _out_.append("\000")
                            i += 2
                        else:
                            _out_.append ("\\")
                            _out_.append(s[i])
                    elif (s[i] == 'u'):
                        hstr = s[i+1:(i + 5)]
                    
                        if (len(hstr) == 4):
                            try:
                                _out_.append(unichr(int(hstr, 16)))
                                i += 5
                            except ValueError:
                                _out_.append("\\")
                                _out_.append(s[i])
                        else:
                            _out_.append("\\")
                            _out_.append(s[i])
                    else:
                        _out_.append("\\")
                        _out_.append(s[i])
                else:
                    _out_.append(c)
            else:
                _out_.append(c)
              
        return str(_out_)


